<head><title>Package: Generic</title><link rel="stylesheet" type="text/css" href="default.css"
 />
</head><table><tr><td colspan=2><span style="font-size:250%;">Lisp-editor</span></td></tr><tr><td valign="top"><h3><a href="Intro.html#Intro">Intro</a></h3><h3><a href="GIL.html#GIL">General Interface Library/Language (Explanation)</a></h3><h3><a href="GIL-use.html#GIL-use">GIL from user perspective</a></h3><h3><a href="GIL-output.html#GIL-output">GIL output languages</a></h3><h3><a href="DEFPACKAGE GENERIC.html#DEFPACKAGE GENERIC">Package: Generic</a></h3><h3><a href="DEFPACKAGE DENEST.html#DEFPACKAGE DENEST">Package: Denest</a></h3><h3><a href="DEFPACKAGE PACKAGE-STUFF.html#DEFPACKAGE PACKAGE-STUFF">Package: Package-stuff</a></h3><h3><a href="DEFPACKAGE EXPRESSION-HOOK.html#DEFPACKAGE EXPRESSION-HOOK">Package: Expression-hook</a></h3><h3><a href="DEFPACKAGE EXPRESSION-SCAN.html#DEFPACKAGE EXPRESSION-SCAN">Package: Expression-scan</a></h3><h3><a href="DEFPACKAGE AUTODOC-GIL.html#DEFPACKAGE AUTODOC-GIL">Package: Autodoc-gil</a></h3><h3><a href="DEFPACKAGE GIL.html#DEFPACKAGE GIL">Package: Gil</a></h3><h3><a href="DEFPACKAGE GIL-SHARE.html#DEFPACKAGE GIL-SHARE">Package: Gil-share</a></h3><h3><a href="DEFPACKAGE GIL-STYLE.html#DEFPACKAGE GIL-STYLE">Package: Gil-style</a></h3><h3><a href="DEFPACKAGE GIL-INFO.html#DEFPACKAGE GIL-INFO">Package: Gil-info</a></h3><h3><a href="DEFPACKAGE GIL-READ.html#DEFPACKAGE GIL-READ">Package: Gil-read</a></h3><h3><a href="DEFPACKAGE GIL-USER.html#DEFPACKAGE GIL-USER">Package: Gil-user</a></h3><h3><a href="DEFPACKAGE GIL-HTML.html#DEFPACKAGE GIL-HTML">Package: Gil-html</a></h3><hr>Hosted by<br><a href="http://developer.berlios.de/"><img src="http://developer.berlios.de/bslogo.php?group_id=0" ></a></td><td><a name="DEFPACKAGE GENERIC"><h1>Package: Generic</h1></a><p>Assortment of little useful macros/functions.</p><p>Uses packages: Common-lisp</p><a name="DEFUN SQR"><h2>defun sqr(x )</h2></a><p>Square of a value.</p><p></p><a name="DEFUN DELIST"><h2>defun delist(x )</h2></a><p>If list, return car, otherwise itself.</p><p></p><a name="DEFUN CURRY-L"><h2>defun curry-l(fun curried )</h2></a><p>Curry to the left; add arguments to the start of the function.
Note: uses apply.. Hope it will optimize.</p><p></p><a name="DEFUN CURRY"><h2>defun curry(fun curried )</h2></a><p>Curry to the right; add arguments to the end of the function.
Note: uses apply.. Hope it will optimize.</p><p></p><a name="DEFUN COMPOSE"><h2>defun compose(fun to )</h2></a><p>Composes two functions.</p><p></p><a name="DEFUN CLAMP"><h2>defun clamp(clamped from to )</h2></a><p>Clamp between two values.</p><p></p><a name="DEFMACRO WITH-STREAM"><h2>defmacro with-stream((stream value start end element-type if-exists if-does-not-exist external-format )&body body )</h2></a><p>Makes a stream based on the value, the keyword arguments correspond to
the functions. Distinguishing between:
*streams used as-is, not closed of course.
*string via make-string-input-stream or make-string-output-stream
depending on direction.
*files(pathnames) (via open, of course)
What is returned is usually the last input, unless it is string-output.</p><p></p><a name="DEFMACRO WITH-MOD-SLOTS"><h2>defmacro with-mod-slots(mod (slots )object &body body )</h2></a><p>WITH-SLOTS, but requires something to be prepended to the
SYMBOL-MACROLET's, this allows you to use two or more objects with
convenient symbols at the same time.</p><p></p><a name="DEFMACRO WITH-MOD-ACCESS"><h2>defmacro with-mod-access(mod (accessors )object &body body )</h2></a><p>Access objects. Lists on accessors/readers or plain functions are seen
as (function &rest args-after) Mod adds some name previously so you can work with multiple of the same.
(Similar to with-mod-slots.)</p><p></p><a name="DEFMACRO WITH-GENSYMS"><h2>defmacro with-gensyms((vars )&body body )</h2></a><p>Makes you some variables with gensyms output in them.</p><p></p><a name="DEFMACRO WITH-ACCESS"><h2>defmacro with-access((accessors )object &body body )</h2></a><p>Access objects. Lists on accessors/readers/ plain functions are seen as
(function &rest args-after).</p><p></p><a name="DEFMACRO WHEN-LET"><h2>defmacro when-let(var cond &body body )</h2></a><p>When, but with the condition, var available.</p><p></p><a name="DEFMACRO WHEN-DO"><h2>defmacro when-do(cond do )</h2></a><p>return-from the condition, if the condition is true.</p><p></p><a name="DEFMACRO VAR-CHANGER"><h2>defmacro var-changer(var-name )</h2></a><p>Makes a variable changer for a given variable.</p><p></p><a name="DEFMACRO STRING-CASE"><h2>defmacro string-case(string cases )</h2></a><p>A case for strings.</p><p></p><a name="DEFMACRO SETF-DEFUN"><h2>defmacro setf-defun(name (args )&body body )</h2></a><p>Make a defun and a setter at the same time.
TODO see though things.</p><p></p><a name="DEFMACRO SETF-"><h2>defmacro setf-(operator set args )</h2></a><p>Changes 'set argument with setf using given operator, and extra
arguments. WARNING/TODO: abstraction leak if set has sideeffects.</p><p></p><a name="DEFMACRO IFT"><h2>defmacro ift(manner self with )</h2></a><p>Returns itself if `(,manner ,self ,@with) true.</p><p></p><a name="DEFMACRO IF-USE"><h2>defmacro if-use(conds )</h2></a><p>Returns the first one that returns non-nil.</p><p></p><a name="DEFMACRO IF-LET"><h2>defmacro if-let(var cond if-t )</h2></a><p>Makes a variable var set by cond, and them does if-t if non-nil and
(optionally)if-f else.</p><p></p><a name="DEFMACRO FOR-MORE"><h2>defmacro for-more(macroname args )</h2></a><p>Applies a series of different arguments to same function.</p><p></p><a name="DEFMACRO DEFVAR_"><h2>defmacro defvar*(var-name init doc )</h2></a><p>Makes variable, then makes it changable</p><p></p><a name="DEFMACRO CASE-LET"><h2>defmacro case-let(var is cases )</h2></a><p>Case, but makes a variable for you.</p><p></p></td></tr></table>