<?xml version="1.0" encoding="iso-8859-1" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><body><table><tbody><tr><td valign="top"><h2>External</h2><h3>Variables</h3><p><a href="denest.html#defvar_*denest-macros*">*denest-macros*</a></p><h3>Function</h3><p><a href="denest.html#defmacro_accumulating">accumulating</a></p><p><a href="denest.html#defmacro_besting">besting</a></p><p><a href="denest.html#defmacro_collecting">collecting</a></p><p><a href="denest.html#defmacro_def-denest-macro">def-denest-macro</a></p><p><a href="denest.html#defmacro_denest">denest</a></p><p><a href="denest.html#defmacro_denest*">denest*</a></p><p><a href="denest.html#defmacro_denest-ret">denest-ret</a></p><p><a href="denest.html#defmacro_maximizing">maximizing</a></p><p><a href="denest.html#defmacro_minimizing">minimizing</a></p><p><a href="denest.html#defmacro_return-accumulate">return-accumulate</a></p><p><a href="denest.html#defmacro_return-accumulate*">return-accumulate*</a></p><p><a href="denest.html#defmacro_summing">summing</a></p><p><a href="denest.html#defmacro_use-denest-macro">use-denest-macro</a></p><h2>Internal</h2><h3>Variables</h3><h3>Function</h3><p><a href="denest.html#defmacro_denest-raw">denest-raw</a></p></td><td><p><h1>package DENEST</h1><p>Macro to denest, remove nestedness of macros
/functions. Was somewhat of a relevation to me and suprising that this
 function isn't being screamed from the rooftops. Turns out that macros
 like iterate might just be trying to fight nestedness.(Mostly)

A few macros are given, some are on keywords and specific to denest, to 
 save namespace.  They do _exactly_ the same as regular macros however! You
 can use them with the USE-DENEST macro. The macros supplied in this packageIf
with non-keyword symbols are exported.

TODO remove some nastyness that might happen if denest is nested with self..
Can it be done?</p><hr /></p><h1>External</h1><h2>Variables</h2><h3><a name="defvar_*denest-macros*"><a href="denest.html#defvar_*denest-macros*">defvar *denest-macros*</a></a></h3><p>Macros for denest when given a keyword.</p><p>Initial value (MAKE-HASH-TABLE)</p><h2>Function</h2><b><h2><a name="defmacro_accumulating"><a href="denest.html#defmacro_accumulating">defmacro accumulating</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;(initial onto operation &optional (by-name 'DENEST:ACCUMULATING) without-let ) &body body </p>Alter a variable with an operation, each time accumulation is called,
 return the result.
Multiple accumulations need to go by different names.<b><h2><a name="defmacro_besting"><a href="denest.html#defmacro_besting">defmacro besting</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;(valuator &key intermediate initial (best (GENSYM)) (by-name 'DENEST:BESTING) (changer (GENSYM)) ) &body body </p>Find best variant of something using function.<b><h2><a name="defmacro_collecting"><a href="denest.html#defmacro_collecting">defmacro collecting</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;(&optional (initial '(LIST)) (onto (GENSYM)) (collect 'DENEST:COLLECTING) (append 'DENEST:APPENDING) (last (GENSYM)) (append-1 (GENSYM)) ) &body body </p>Collect everything asked to, return result. (Also, appending)
If you want to use two different collectings, you need to provide the
 collect argument.(To avoid namespace collision, and to separate the two.)<b><h2><a name="defmacro_def-denest-macro"><a href="denest.html#defmacro_def-denest-macro">defmacro def-denest-macro</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;name (&rest args ) &body body </p>Create a macro applied when denests meets an keyword.
 :return is reserved.<b><h2><a name="defmacro_denest"><a href="denest.html#defmacro_denest">defmacro denest</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;&rest args </p>Un-nests stuff, reconstructs macros in order with the body at the end.
Best and easiest description is: (But the actual version has some more 
 (defmacro denest (&rest args)
   (if (null (cdr args))
     (car args)
     `(,@(car args)
       (denest ,@(cdr args)))))<b><h2><a name="defmacro_denest*"><a href="denest.html#defmacro_denest*">defmacro denest*</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;&rest arguments </p>denest, but adds some parenthesis so you don't have to write them. 
Has significant disadvantage; can't do stuff where the body location isn't
 entirely indicated by the parenthesis, like in WITH-SLOTS,
 DESTRUCTURING-BIND, MULTIPLE-VALUE-BIND.<b><h2><a name="defmacro_denest-ret"><a href="denest.html#defmacro_denest-ret">defmacro denest-ret</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;&body body </p>Marks where to go back to when the macro returns.
 Only thing that might ever need changing in macros. Doesn't affect normal
 operation of macro.<b><h2><a name="defmacro_maximizing"><a href="denest.html#defmacro_maximizing">defmacro maximizing</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;(&optional (initial 0) (max (GENSYM)) ) &body body </p>Maximizes a number. WARNING, TODO can get rid of initial?<b><h2><a name="defmacro_minimizing"><a href="denest.html#defmacro_minimizing">defmacro minimizing</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;(&optional (initial 0) (min (GENSYM)) ) &body body </p>Minimized a number. WARNING, TODO can get rid of initial?<b><h2><a name="defmacro_return-accumulate"><a href="denest.html#defmacro_return-accumulate">defmacro return-accumulate</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;(&rest accumulation-manners ) &body body </p>Produces accumulation into different values-output..
Must given accumulation-manners given in same way as denest ones, they must
 have form (macro-name (something accumulating-variable ...) ...)<h3>Used macros and functions</h3><h4>From package DENEST</h4><a href="denest.html#defmacro_use-denest-macro">use-denest-macro</a>, <a href="denest.html#defmacro_denest-ret">denest-ret</a>, <a href="denest.html#defmacro_denest-raw">denest-raw</a>, <a href="denest.html#defmacro_denest">denest</a>, <a href="denest.html#defmacro_collecting">collecting</a>, col-var, col-accum<b><h2><a name="defmacro_return-accumulate*"><a href="denest.html#defmacro_return-accumulate*">defmacro return-accumulate*</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;(&rest accumulation-manners ) &body body </p>Same as return-accumulate, but allows for less parentheses.<b><h2><a name="defmacro_summing"><a href="denest.html#defmacro_summing">defmacro summing</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;(&optional initial (onto (GENSYM)) without-let ) &body body </p>Sum everything asked to, return result.<b><h2><a name="defmacro_use-denest-macro"><a href="denest.html#defmacro_use-denest-macro">defmacro use-denest-macro</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;name &rest args </p>Applies a denest macro.<h1>Internal</h1><h2>Variables</h2><h2>Function</h2><b><h2><a name="defmacro_denest-raw"><a href="denest.html#defmacro_denest-raw">defmacro denest-raw</a></a></h2></b><p>&nbsp;&nbsp;&nbsp;&rest args </p>Raw version of denest. Doesn't add the blocks and macrolets.</td></tr></tbody></table></body></html>