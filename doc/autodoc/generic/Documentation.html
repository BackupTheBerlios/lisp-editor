<?xml version="1.0" encoding="iso-8859-1" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Documentation for  and GENERIC.</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /><meta name="description" content="contents page from autodocumentation." /></head><body><table><tbody><tr><td valign="top"><h3>Package GENERIC</h3><p><a href="#WITH-MOD-SLOTS">WITH-MOD-SLOTS</a></p><p><a href="#WITH-MOD-SLOTS">WITH-MOD-SLOTS</a></p><p><a href="#WITH-GENSYMS">WITH-GENSYMS</a></p><p><a href="#WITH-GENSYMS">WITH-GENSYMS</a></p><p><a href="#WHEN-LET">WHEN-LET</a></p><p><a href="#WHEN-LET">WHEN-LET</a></p><p><a href="#WHEN-DO">WHEN-DO</a></p><p><a href="#WHEN-DO">WHEN-DO</a></p><p><a href="#STRING-CASE">STRING-CASE</a></p><p><a href="#STRING-CASE">STRING-CASE</a></p><p><a href="#SQR">SQR</a></p><p><a href="#SQR">SQR</a></p><p><a href="#SETF-">SETF-</a></p><p><a href="#SETF-">SETF-</a></p><p><a href="#LET-FROM-LIST">LET-FROM-LIST</a></p><p><a href="#LET-FROM-LIST">LET-FROM-LIST</a></p><p><a href="#IFT">IFT</a></p><p><a href="#IFT">IFT</a></p><p><a href="#IF-USE">IF-USE</a></p><p><a href="#IF-USE">IF-USE</a></p><p><a href="#IF-LET">IF-LET</a></p><p><a href="#IF-LET">IF-LET</a></p><p><a href="#FOR-MORE">FOR-MORE</a></p><p><a href="#FOR-MORE">FOR-MORE</a></p><p><a href="#DELIST">DELIST</a></p><p><a href="#DELIST">DELIST</a></p><p><a href="#COND*">COND*</a></p><p><a href="#COND*">COND*</a></p><p><a href="#CLAMP">CLAMP</a></p><p><a href="#CLAMP">CLAMP</a></p><p><a href="#CASE-LET">CASE-LET</a></p><p><a href="#CASE-LET">CASE-LET</a></p></td><td><h2>Package GENERIC</h2><table><tbody><tr><td><a name="WITH-MOD-SLOTS"><h2>macro: with-mod-slots</h2></a><p>Arguments: <b>MOD &REST SLOTS  OBJECT &BODY BODY </b></p><p>WITH-SLOTS, but requires something to be prepended to the
 SYMBOL-MACROLET's, this allows you to use two or more objects with
 convenient symbols at the same time.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>>, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="WITH-MOD-SLOTS"><h2>macro: with-mod-slots</h2></a><p>Arguments: <b>MOD &REST SLOTS  OBJECT &BODY BODY </b></p><p>WITH-SLOTS, but requires something to be prepended to the
 SYMBOL-MACROLET's, this allows you to use two or more objects with
 convenient symbols at the same time.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>>, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="WITH-GENSYMS"><h2>macro: with-gensyms</h2></a><p>Arguments: <b>&REST VARS  &BODY BODY </b></p><p>Makes you some variables with gensyms output in them.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>SETF, NOT, LIST, COND, CDR, CAR, ATOM, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="WITH-GENSYMS"><h2>macro: with-gensyms</h2></a><p>Arguments: <b>&REST VARS  &BODY BODY </b></p><p>Makes you some variables with gensyms output in them.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>SETF, NOT, LIST, COND, CDR, CAR, ATOM, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="WHEN-LET"><h2>macro: when-let</h2></a><p>Arguments: <b>VAR COND &BODY BODY </b></p><p>When, but with the condition, var available.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>NOT, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="WHEN-LET"><h2>macro: when-let</h2></a><p>Arguments: <b>VAR COND &BODY BODY </b></p><p>When, but with the condition, var available.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>NOT, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="WHEN-DO"><h2>macro: when-do</h2></a><p>Arguments: <b>COND &REST DO </b></p><p>return-from the condition, if the condition is true.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>GENSYM, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="WHEN-DO"><h2>macro: when-do</h2></a><p>Arguments: <b>COND &REST DO </b></p><p>return-from the condition, if the condition is true.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>GENSYM, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="STRING-CASE"><h2>macro: string-case</h2></a><p>Arguments: <b>STRING &REST CASES </b></p><p>A case for strings.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>EQL, ENDP, CONS, COND, CDR, CAR, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="STRING-CASE"><h2>macro: string-case</h2></a><p>Arguments: <b>STRING &REST CASES </b></p><p>A case for strings.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>EQL, ENDP, CONS, COND, CDR, CAR, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="SQR"><h2>function: sqr</h2></a><p>Arguments: <b>X </b></p><p>Square of a value.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>*, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="SQR"><h2>function: sqr</h2></a><p>Arguments: <b>X </b></p><p>Square of a value.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>*, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="SETF-"><h2>macro: setf-</h2></a><p>Arguments: <b>OPERATOR SET &REST ARGS </b></p><p>Changes 'set argument with setf using given operator, and extra
 arguments. WARNING/TODO: abstraction leak if set has sideeffects.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>NOT, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="SETF-"><h2>macro: setf-</h2></a><p>Arguments: <b>OPERATOR SET &REST ARGS </b></p><p>Changes 'set argument with setf using given operator, and extra
 arguments. WARNING/TODO: abstraction leak if set has sideeffects.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>NOT, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="LET-FROM-LIST"><h2>macro: let-from-list</h2></a><p>Arguments: <b>&REST VARS  LIST </b></p><p>Sets given variables vars according to list, as far as possible.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>1+, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="LET-FROM-LIST"><h2>macro: let-from-list</h2></a><p>Arguments: <b>&REST VARS  LIST </b></p><p>Sets given variables vars according to list, as far as possible.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>1+, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="IFT"><h2>macro: ift</h2></a><p>Arguments: <b>MANNER SELF &REST WITH </b></p><p>Returns itself if `(,manner ,self ,@with) true.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>GENSYM, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="IFT"><h2>macro: ift</h2></a><p>Arguments: <b>MANNER SELF &REST WITH </b></p><p>Returns itself if `(,manner ,self ,@with) true.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>GENSYM, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="IF-USE"><h2>macro: if-use</h2></a><p>Arguments: <b>&REST CONDS </b></p><p>Returns the first one that returns non-nil.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>GENSYM, CDR, CAR, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="IF-USE"><h2>macro: if-use</h2></a><p>Arguments: <b>&REST CONDS </b></p><p>Returns the first one that returns non-nil.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>GENSYM, CDR, CAR, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="IF-LET"><h2>macro: if-let</h2></a><p>Arguments: <b>VAR COND IF-T &OPTIONAL (GENERIC::IF-F NIL) </b></p><p>Makes a variable var set by cond, and them does if-t if non-nil and
 (optionally)if-f else.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>NOT, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="IF-LET"><h2>macro: if-let</h2></a><p>Arguments: <b>VAR COND IF-T &OPTIONAL (GENERIC::IF-F NIL) </b></p><p>Makes a variable var set by cond, and them does if-t if non-nil and
 (optionally)if-f else.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>NOT, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="FOR-MORE"><h2>macro: for-more</h2></a><p>Arguments: <b>MACRONAME &REST ARGS </b></p><p>Applies a series of different arguments to same function.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>RPLACD, NOT, LOOP, LIST, ENDP, CONS, COND, CDR, CAR, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="FOR-MORE"><h2>macro: for-more</h2></a><p>Arguments: <b>MACRONAME &REST ARGS </b></p><p>Applies a series of different arguments to same function.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>RPLACD, NOT, LOOP, LIST, ENDP, CONS, COND, CDR, CAR, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="DELIST"><h2>function: delist</h2></a><p>Arguments: <b>X </b></p><p>If list, return car, otherwise itself.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>CAR, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="DELIST"><h2>function: delist</h2></a><p>Arguments: <b>X </b></p><p>If list, return car, otherwise itself.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>CAR, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="COND*"><h2>macro: cond*</h2></a><p>Arguments: <b>&REST CLAUSES </b></p><p>Cond where keywords at start of clauses mean things.
:let makes a single conditition a variable for you, available in body.
:with(*) makes a bunch of variables which is then available for the clause
 condition and body.
:or-let(*) and :and-let make you a series of variables that all have to be
 true/false.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package ITERATE: </h4>FINISH, <h4>In package COMMON-LISP: </h4>SETF, LIST, EQL, COND, CDR, CAR, CADR, ATOM, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="COND*"><h2>macro: cond*</h2></a><p>Arguments: <b>&REST CLAUSES </b></p><p>Cond where keywords at start of clauses mean things.
:let makes a single conditition a variable for you, available in body.
:with(*) makes a bunch of variables which is then available for the clause
 condition and body.
:or-let(*) and :and-let make you a series of variables that all have to be
 true/false.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package ITERATE: </h4>FINISH, <h4>In package COMMON-LISP: </h4>SETF, LIST, EQL, COND, CDR, CAR, CADR, ATOM, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="CLAMP"><h2>function: clamp</h2></a><p>Arguments: <b>CLAMPED FROM TO </b></p><p>Clamp between two values.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>>, <, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="CLAMP"><h2>function: clamp</h2></a><p>Arguments: <b>CLAMPED FROM TO </b></p><p>Clamp between two values.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>>, <, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="CASE-LET"><h2>macro: case-let</h2></a><p>Arguments: <b>VAR IS &REST CASES </b></p><p>Case, but makes a variable for you.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>NOT, COND, </p><hr /></td></tr></tbody><table><tbody><tr><td><a name="CASE-LET"><h2>macro: case-let</h2></a><p>Arguments: <b>VAR IS &REST CASES </b></p><p>Case, but makes a variable for you.</p><p><h3>Links to other functions/macros</h3><h4>Outside current documenting-set.</h4><h4>In package COMMON-LISP: </h4>NOT, COND, </p><hr /></td></tr></tbody></td></tr></tbody></table></body></html>